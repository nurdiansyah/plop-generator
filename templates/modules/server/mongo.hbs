import { BulkWriteOperation, Collection, Db } from "mongodb";
import { {{ pascalCase  module }}Repo } from "../{{ pascalCase  module }}Repo";
import { {{ constantCase  module }}_REPO_KEY } from "../{{ pascalCase  module }}Repo";
import { {{ pascalCase  module }}, {{ pascalCase  module }}Error, {{ pascalCase  module }}Input } from "@deboxsoft/{{ kebabCase module }}-api";

import { Container } from "@deboxsoft/module-core";
import { BaseRepository, getMongoDb } from "@deboxsoft/module-mongo";

export const create{{ pascalCase  module }}Repo = () => {
  const db = getMongoDb();
  const {{ camelCase  module }}Repo = new {{ pascalCase  module }}Collection(db);
  Container.set({{ constantCase  module }}_REPO_KEY, {{ camelCase  module }}Repo);
  return {{ camelCase  module }}Repo;
};

export class {{ pascalCase  module }}Collection extends BaseRepository implements {{ pascalCase  module }}Repo {
  collection: Collection;
  constructor(db: Db) {
    super();
    this.collection = db.collection("{{ pascalCase  module }}");
  }

  async create(input: {{ pascalCase  module }}Input) {
    try {
      const metadata = await this.collection.insertOne(this._parseDataInput(input));
      if (metadata.result.ok === 1) {
        return { metadata, data: metadata.insertedId };
      }
      throw new {{ pascalCase  module }}Error("{{ constantCase  module }}_CREATE_FAILED");
    } catch (e) {
      if (e.code === 11000) {
        throw new {{ pascalCase  module }}Error("{{ constantCase  module }}_DUPLICATE", e.keyValue._id);
      }
      throw e;
    }
  }

  async update(id, input: {{ pascalCase  module }}Input) {
    const metadata = await this.collection.updateOne(
      { _id: id },
      { $set: input }
    );
    return { metadata, data: metadata.result.ok === 1 };
  }

  async remove(id: string | string[]) {
    try {
      if (Array.isArray(id)) {
        const metadata = await this.collection.deleteMany({ _id: { $in: id } });
        return { metadata, data: metadata.result.ok === 1 };
      }
      const metadata = await this.collection.deleteOne({ _id: id });
      return { metadata, data: metadata.result.ok === 1 };
    } catch (e) {
      throw e;
    }
  }

  find(query): Promise<{{ pascalCase  module }}[]> {
    return this.collection
      .find(query, { sort: { _id: 1 } })
      .map(this._parseDataOutput)
      .toArray();
  }

  findById(id: string): Promise<{{ pascalCase  module }} | undefined> {
    return this.collection.findOne({ _id: id }).then(this._parseDataOutput);
  }

  _parseDataInput({ id, ...input }: {{ pascalCase  module }}Input) {
    return { _id: id, ...input };
  }

  _parseDataOutput({ _id, ...input }: any): {{ pascalCase  module }} {
    return { id: _id, ...input };
  }
}
